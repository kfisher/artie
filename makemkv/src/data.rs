// Copyright 2025 Kevin Fisher. All rights reserved.
// SPDX-License-Identifier: GPL-3.0-only

//! Data representing information about a disc's content.
//!
//! Defines the data types used to represent the information about the content on a DVD or Blu-ray
//! disc that is extracted by MakeMKV with the "info" command.

use std::collections::hash_map::Entry;
use std::path::Path;
use std::{collections::HashMap, fs::OpenOptions};

use serde::{Deserialize, Serialize};

use crate::error::{Error, Result};

/// The maximum number of titles that can added to a title.
///
/// This value is a lot higher that what the actual maximum number of titles that will be. Its main
/// purpose is to protect against an error in coding or bad data being generated by MakeMKV causing
/// an infinite (or extremely large) number of titles being added.
const MAX_TITLE_COUNT: usize = 100;

/// The maximum number of streams that can added to a title.
///
/// This value is a lot higher that what the actual maximum number of streams that will be. Its
/// main purpose is to protect against an error in coding or bad data being generated by MakeMKV
/// causing an infinite (or extremely large) number of streams being added.
const MAX_STREAM_COUNT: usize = 100;

/// Specifies the information attribute types that can be extracted by MakeMKV
/// by running the 'info' command.
///
/// These attributes can apply to either the disc, titles within the disc, or
/// streams (audio, subtitle, or video).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Deserialize, Serialize)]
pub enum Attribute {
    Unknown,
    Type,
    Name,
    LangCode,
    LangName,
    CodecId,
    CodecShort,
    CodecLong,
    ChapterCount,
    Duration,
    DiskSize,
    DiskSizeBytes,
    StreamTypeExtension,
    Bitrate,
    AudioChannelsCount,
    AngleInfo,
    SourceFileName,
    AudioSampleRate,
    AudioSampleSize,
    VideoSize,
    VideoAspectRatio,
    VideoFrameRate,
    StreamFlags,
    DateTime,
    OriginalTitleId,
    SegmentsCount,
    SegmentsMap,
    OutputFileName,
    MetadataLanguageCode,
    MetadataLanguageName,
    TreeInfo,
    PanelTitle,
    VolumeName,
    OrderWeight,
    OutputFormat,
    OutputFormatDescription,
    SeamlessInfo,
    PanelText,
    MkvFlags,
    MkvFlagsText,
    AudioChannelLayoutName,
    OutputCodecShort,
    OutputConversionType,
    OutputAudioSampleRate,
    OutputAudioSampleSize,
    OutputAudioChannelsCount,
    OutputAudioChannelLayoutName,
    OutputAudioChannelLayout,
    OutputAudioMixDescription,
    Comment,
    OffsetSequenceId,
}

/// Information extracted from a DVD or Blu-ray about its contents.
#[derive(Deserialize, Serialize)]
pub struct DiscInfo {
    /// Map containing the attributes of the disc itself where each key is the attribute id and the
    /// value is the attribute's value.
    pub attributes: HashMap<Attribute, String>,

    /// List of titles from the disc.
    pub titles: Vec<Option<TitleInfo>>,
}

/// Information for a title on the disc.
#[derive(Deserialize, Serialize)]
pub struct TitleInfo {
    /// Map containing the attributes of the title where each key is the attribute id and the value
    /// is the attribute's value.
    pub attributes: HashMap<Attribute, String>,

    /// List of streams (audio, video, subtitle) for the title.
    pub streams: Vec<Option<StreamInfo>>,
}

/// Information for a video, audio, or subtitle stream in a title.
#[derive(Deserialize, Serialize)]
pub struct StreamInfo {
    /// Map containing the attributes of the stream where each key is the attribute id and the
    /// value is the attribute's value.
    pub attributes: HashMap<Attribute, String>,
}

impl DiscInfo {
    /// Constructs a new `DiscInfo` instance.
    pub fn new() -> Self {
        DiscInfo {
            attributes: HashMap::new(),
            titles: Vec::new(),
        }
    }

    /// Adds a disc attribute.
    pub fn add_attribute(&mut self, attr: Attribute, value: &str) -> Result<()> {
        if let Entry::Vacant(entry) = self.attributes.entry(attr) {
            let _ = entry.insert(value.to_owned());
            Ok(())
        } else {
            Err(Error::DuplicateAttribute { attr })
        }
    }

    /// Adds a title attribute.
    ///
    /// If the title doesn't exist for the provided index does not exist yet it will be created
    /// filling any title slots between the end of the titles array and the new title with a value
    /// of None.
    ///
    /// # Panics
    ///
    /// Panics if `index` is greater than the maximum number of titles allowed.
    pub fn add_title_attribute(
        &mut self,
        index: usize,
        attr: Attribute,
        value: &str,
    ) -> Result<()> {
        // Protect against bad code causing memory runaway. In this case, we want the program to
        // panic as something terrible has happened.
        if index > MAX_TITLE_COUNT {
            panic!(
                "Exceeded maximum number of titles allowed (index = {})",
                index
            );
        }

        if index >= self.titles.len() {
            self.titles.resize_with(index + 1, || None);
        }

        let title = self.titles[index].get_or_insert(TitleInfo::new());
        title.add_attribute(attr, value)
    }

    /// Adds a stream attribute.
    ///
    /// If the title doesn't exist for the provided index does not exist yet it will be created
    /// filling any title slots between the end of the titles array and the new title with a value
    /// of None. Similarly, if the stream doesn't exist within the title, it will be created
    /// filling any stream slots.
    ///
    /// # Panics
    ///
    /// Panics if `title_index` or `stream_index is greater than the maximum number of titles or
    /// streams allowed respectively.
    pub fn add_stream_attribute(
        &mut self,
        title_index: usize,
        stream_index: usize,
        attr: Attribute,
        value: &str,
    ) -> Result<()> {
        // Protect against bad code causing memory runaway. In this case, we want the program to
        // panic as something terrible has happened.
        if title_index > MAX_TITLE_COUNT {
            panic!(
                "Exceeded maximum number of titles allowed (title_index = {})",
                title_index
            );
        }

        if title_index >= self.titles.len() {
            self.titles.resize_with(title_index + 1, || None);
        }

        let title = self.titles[title_index].get_or_insert(TitleInfo::new());
        title.add_stream_attribute(stream_index, attr, value)
    }

    /// Loads the disc information from a JSON file at the provided path.
    pub fn load(path: &Path) -> Result<DiscInfo> {
        let file = OpenOptions::new()
                .read(true)
                .open(path)
                .map_err(|error| Error::FileOpenError {
                    path: path.to_path_buf(),
                    error,
                })?;
        serde_json::from_reader(&file).map_err(|error| Error::JsonError {
            path: path.to_path_buf(),
            error,
        })
    }

    /// Saves the disc information as JSON text to the provided path.
    ///
    /// This will fail if the provided path already exists.
    pub fn save(&self, path: &Path) -> Result<()> {
        let file = OpenOptions::new()
            .create_new(true)
            .write(true)
            .open(path)
            .map_err(|error| Error::FileOpenError {
                path: path.to_path_buf(),
                error,
            })?;
        serde_json::to_writer_pretty(file, &self).map_err(|error| Error::JsonError {
            path: path.to_path_buf(),
            error,
        })
    }
}

impl Default for DiscInfo {
    fn default() -> Self {
        Self::new()
    }
}

impl TitleInfo {
    /// Constructs a new `TitleInfo` instance.
    pub fn new() -> Self {
        TitleInfo {
            attributes: HashMap::new(),
            streams: Vec::new(),
        }
    }

    /// Adds a title attribute.
    pub fn add_attribute(&mut self, attr: Attribute, value: &str) -> Result<()> {
        if let Entry::Vacant(entry) = self.attributes.entry(attr) {
            let _ = entry.insert(value.to_owned());
            Ok(())
        } else {
            Err(Error::DuplicateAttribute { attr })
        }
    }

    /// Adds a stream attribute to one of the title's streams.
    ///
    /// If a stream for the provided index `index` does not exist yet it will be created filling in
    /// any stream slots between the end of the streams array and the new stream with None.
    ///
    /// # Panics
    ///
    /// Panics if `index` is greater than the maximum number of streams allowed.
    pub fn add_stream_attribute(
        &mut self,
        index: usize,
        attr: Attribute,
        value: &str,
    ) -> Result<()> {
        // Protect against bad code causing memory runaway. In this case, we want the program to
        // panic as something terrible has happened.
        if index > MAX_STREAM_COUNT {
            panic!(
                "Exceeded maximum number of streams allowed (index = {})",
                index
            );
        }

        if index >= self.streams.len() {
            self.streams.resize_with(index + 1, || None);
        }

        let stream = self.streams[index].get_or_insert(StreamInfo::new());
        stream.add_attribute(attr, value)
    }
}

impl Default for TitleInfo {
    fn default() -> Self {
        Self::new()
    }
}

impl StreamInfo {
    /// Constructs a new `StreamInfo` instance.
    pub fn new() -> Self {
        StreamInfo {
            attributes: HashMap::new(),
        }
    }

    /// Adds a stream attribute.
    pub fn add_attribute(&mut self, attr: Attribute, value: &str) -> Result<()> {
        if let Entry::Vacant(entry) = self.attributes.entry(attr) {
            let _ = entry.insert(value.to_owned());
            Ok(())
        } else {
            Err(Error::DuplicateAttribute { attr })
        }
    }
}

impl Default for StreamInfo {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_utils::TempFile;

    fn is_dup_attr(e: Error, a: &Attribute) -> bool {
        use Error::*;
        match e {
            DuplicateAttribute { attr: b } => *a == b,
            _ => false,
        }
    }

    fn is_dup_name(e: Error) -> bool {
        is_dup_attr(e, &Attribute::Name)
    }

    #[test]
    fn disc_info_add_attribute() {
        let mut di = DiscInfo::new();
        assert_eq!(di.add_attribute(Attribute::Name, "Name").is_ok(), true);
        assert_eq!(di.attributes.is_empty(), false);
        assert_eq!(di.attributes.get(&Attribute::Name), Some(&"Name".into()));
        assert_eq!(
            di.add_attribute(Attribute::Name, "Name")
                .is_err_and(is_dup_name),
            true
        );
    }

    #[test]
    fn disc_info_add_title_attribute() {
        let mut di = DiscInfo::new();
        assert_eq!(
            di.add_title_attribute(0, Attribute::Name, "Name").is_ok(),
            true
        );
        assert_eq!(
            di.add_title_attribute(3, Attribute::Name, "Name").is_ok(),
            true
        );
        assert_eq!(di.titles.len(), 4);
        assert_eq!(di.titles[0].is_some(), true);
        assert_eq!(
            di.titles[0]
                .as_ref()
                .unwrap()
                .attributes
                .get(&Attribute::Name),
            Some(&"Name".into())
        );
        assert_eq!(di.titles[1].is_none(), true);
        assert_eq!(di.titles[2].is_none(), true);
        assert_eq!(di.titles[3].is_some(), true);
        assert_eq!(
            di.titles[3]
                .as_ref()
                .unwrap()
                .attributes
                .get(&Attribute::Name),
            Some(&"Name".into())
        );
    }

    #[test]
    fn disc_info_add_stream_attribute() {
        let mut di = DiscInfo::new();
        assert_eq!(
            di.add_stream_attribute(0, 0, Attribute::Name, "Name")
                .is_ok(),
            true
        );
        assert_eq!(di.titles.len(), 1);
        assert_eq!(di.titles[0].is_some(), true);

        let ti = di.titles[0].as_ref().unwrap();
        assert_eq!(ti.streams.len(), 1);
        assert_eq!(ti.streams[0].is_some(), true);
        assert_eq!(
            ti.streams[0]
                .as_ref()
                .unwrap()
                .attributes
                .get(&Attribute::Name),
            Some(&"Name".into())
        );
    }

    #[test]
    fn disc_info_save_and_load() {
        let file_name = "artie.makemkv.test.disc_info_save_to_file";
        let temp_file = TempFile(std::env::temp_dir().join(file_name));

        {
            let mut di = DiscInfo::new();
            di.add_attribute(Attribute::Name, "Disc Name").unwrap();
            di.add_title_attribute(0, Attribute::Name, "Title Name")
                .unwrap();
            di.add_stream_attribute(0, 0, Attribute::Name, "Stream Name")
                .unwrap();
            di.save(temp_file.path()).unwrap();
        }

        {
            let di = DiscInfo::load(temp_file.path()).unwrap();

            let attr = di.attributes.get(&Attribute::Name).unwrap();
            assert_eq!(attr, "Disc Name");

            let ti = di.titles[0].as_ref().unwrap();
            let attr = ti.attributes.get(&Attribute::Name).unwrap();
            assert_eq!(attr, "Title Name");

            let si = ti.streams[0].as_ref().unwrap();
            let attr = si.attributes.get(&Attribute::Name).unwrap();
            assert_eq!(attr, "Stream Name");
        }
    }

    #[test]
    fn title_info_add_attribute() {
        let mut ti = TitleInfo::new();
        assert_eq!(ti.add_attribute(Attribute::Name, "Name").is_ok(), true);
        assert_eq!(ti.attributes.is_empty(), false);
        assert_eq!(ti.attributes.get(&Attribute::Name), Some(&"Name".into()));
        assert_eq!(
            ti.add_attribute(Attribute::Name, "Name")
                .is_err_and(is_dup_name),
            true
        );
    }

    #[test]
    fn title_info_add_stream_attribute() {
        let mut ti = TitleInfo::new();
        assert_eq!(
            ti.add_stream_attribute(0, Attribute::Name, "Name").is_ok(),
            true
        );
        assert_eq!(
            ti.add_stream_attribute(3, Attribute::Name, "Name").is_ok(),
            true
        );
        assert_eq!(ti.streams.len(), 4);
        assert_eq!(ti.streams[0].is_some(), true);
        assert_eq!(
            ti.streams[0]
                .as_ref()
                .unwrap()
                .attributes
                .get(&Attribute::Name),
            Some(&"Name".into())
        );
        assert_eq!(ti.streams[1].is_none(), true);
        assert_eq!(ti.streams[2].is_none(), true);
        assert_eq!(ti.streams[3].is_some(), true);
        assert_eq!(
            ti.streams[3]
                .as_ref()
                .unwrap()
                .attributes
                .get(&Attribute::Name),
            Some(&"Name".into())
        );
    }

    #[test]
    fn stream_info_add_attribute() {
        let mut si = StreamInfo::new();
        assert_eq!(si.add_attribute(Attribute::Name, "Name").is_ok(), true);
        assert_eq!(si.attributes.is_empty(), false);
        assert_eq!(si.attributes.get(&Attribute::Name), Some(&"Name".into()));
        assert_eq!(
            si.add_attribute(Attribute::Name, "Name")
                .is_err_and(is_dup_name),
            true
        );
    }
}
